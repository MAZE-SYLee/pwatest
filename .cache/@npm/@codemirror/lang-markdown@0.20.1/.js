import{EditorSelection as e,Prec as t}from"/@npm/@codemirror/state";import{keymap as r}from"/@npm/@codemirror/view";import{defineLanguageFacet as n,foldNodeProp as o,indentNodeProp as i,languageDataProp as s,Language as a,LanguageDescription as m,ParseContext as l,syntaxTree as f,LanguageSupport as u}from"/@npm/@codemirror/language";import{parser as c,GFM as g,Subscript as h,Superscript as p,Emoji as d,MarkdownParser as k,parseCode as x}from"/@npm/@lezer/markdown";import{html as L}from"/@npm/@codemirror/lang-html";const A=n({block:{open:"\x3c!--",close:"--\x3e"}}),b=c.configure({props:[o.add(e=>{if(e.is("Block")&&!e.is("Document"))return(e,t)=>({from:t.doc.lineAt(e.from).to,to:e.to})}),i.add({Document:()=>null}),s.add({Document:A})]});function mkLang(e){return new a(A,e)}const B=mkLang(b),w=mkLang(b.configure([g,h,p,d]));function nodeStart(e,t){return t.sliceString(e.from,e.from+50)}class S{constructor(e,t,r,n,o,i,s){this.node=e,this.from=t,this.to=r,this.spaceBefore=n,this.spaceAfter=o,this.type=i,this.item=s}blank(e=!0){let t=this.spaceBefore;if("Blockquote"==this.node.name)t+=">";else for(let r=this.to-this.from-t.length-this.spaceAfter.length;r>0;r--)t+=" ";return t+(e?this.spaceAfter:"")}marker(e,t){let r="OrderedList"==this.node.name?String(+itemNumber(this.item,e)[2]+t):"";return this.spaceBefore+r+this.type+this.spaceAfter}}function getContext(e,t,r){let n=[];for(let s=e;s&&"Document"!=s.name;s=s.parent)"ListItem"!=s.name&&"Blockquote"!=s.name||n.push(s);let o=[],i=0;for(let s=n.length-1;s>=0;s--){let e,a=n[s],m=i;if("Blockquote"==a.name&&(e=/^[ \t]*>( ?)/.exec(t.slice(i))))i+=e[0].length,o.push(new S(a,m,i,"",e[1],">",null));else if("ListItem"==a.name&&"OrderedList"==a.parent.name&&(e=/^([ \t]*)\d+([.)])([ \t]*)/.exec(nodeStart(a,r)))){let t=e[3],r=e[0].length;t.length>=4&&(t=t.slice(0,t.length-4),r-=4),i+=r,o.push(new S(a.parent,m,i,e[1],t,e[2],a))}else if("ListItem"==a.name&&"BulletList"==a.parent.name&&(e=/^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(nodeStart(a,r)))){let t=e[4],r=e[0].length;t.length>4&&(t=t.slice(0,t.length-4),r-=4);let n=e[2];e[3]&&(n+=e[3].replace(/[xX]/," ")),i+=r,o.push(new S(a.parent,m,i,e[1],t,n,a))}}return o}function itemNumber(e,t){return/^(\s*)(\d+)(?=[.)])/.exec(t.sliceString(e.from,e.from+10))}function renumberList(e,t,r,n=0){for(let o=-1,i=e;;){if("ListItem"==i.name){let e=itemNumber(i,t),s=+e[2];if(o>=0){if(s!=o+1)return;r.push({from:i.from+e[1].length,to:i.from+e[0].length,insert:String(o+2+n)})}o=s}let e=i.nextSibling;if(!e)break;i=e}}const insertNewlineContinueMarkup=({state:t,dispatch:r})=>{let n=f(t),{doc:o}=t,i=null,s=t.changeByRange(r=>{if(!r.empty||!w.isActiveAt(t,r.from))return i={range:r};let s=r.from,a=o.lineAt(s),m=getContext(n.resolveInner(s,-1),a.text,o);for(;m.length&&m[m.length-1].from>s-a.from;)m.pop();if(!m.length)return i={range:r};let l=m[m.length-1];if(l.to-l.spaceAfter.length>s-a.from)return i={range:r};let f=s>=l.to-l.spaceAfter.length&&!/\S/.test(a.text.slice(l.to));if(l.item&&f){if(l.node.firstChild.to>=s||a.from>0&&!/[^\s>]/.test(o.lineAt(a.from-1).text)){let t,r=m.length>1?m[m.length-2]:null,n="";r&&r.item?(t=a.from+r.from,n=r.marker(o,1)):t=a.from+(r?r.to:0);let i=[{from:t,to:s,insert:n}];return"OrderedList"==l.node.name&&renumberList(l.item,o,i,-2),r&&"OrderedList"==r.node.name&&renumberList(r.item,o,i),{range:e.cursor(t+n.length),changes:i}}{let r="";for(let e=0,t=m.length-2;e<=t;e++)r+=m[e].blank(e<t);return r+=t.lineBreak,{range:e.cursor(s+r.length),changes:{from:a.from,insert:r}}}}if("Blockquote"==l.node.name&&f&&a.from){let e=o.lineAt(a.from-1),n=/>\s*$/.exec(e.text);if(n&&n.index==l.from){let o=t.changes([{from:e.from+n.index,to:e.to},{from:a.from+l.from,to:a.to}]);return{range:r.map(o),changes:o}}}let u=[];"OrderedList"==l.node.name&&renumberList(l.item,o,u);let c=t.lineBreak,g=l.item&&l.item.from<a.from;if(!g||/^[\s\d.)\-+*>]*/.exec(a.text)[0].length>=l.to)for(let e=0,t=m.length-1;e<=t;e++)c+=e!=t||g?m[e].blank():m[e].marker(o,1);let h=s;for(;h>a.from&&/\s/.test(a.text.charAt(h-a.from-1));)h--;return u.push({from:h,to:s,insert:c}),{range:e.cursor(h+c.length),changes:u}});return!i&&(r(t.update(s,{scrollIntoView:!0,userEvent:"input"})),!0)};function isMark(e){return"QuoteMark"==e.name||"ListMark"==e.name}const deleteMarkupBackward=({state:t,dispatch:r})=>{let n=f(t),o=null,i=t.changeByRange(r=>{let i=r.from,{doc:s}=t;if(r.empty&&w.isActiveAt(t,r.from)){let t=s.lineAt(i),o=getContext(function(e,t){let r,n=e.resolveInner(t,-1),o=t;for(isMark(n)&&(o=n.from,n=n.parent);r=n.childBefore(o);)if(isMark(r))o=r.from;else{if("OrderedList"!=r.name&&"BulletList"!=r.name)break;n=r.lastChild,o=n.to}return n}(n,i),t.text,s);if(o.length){let n=o[o.length-1],s=n.to-n.spaceAfter.length+(n.spaceAfter?1:0);if(i-t.from>s&&!/\S/.test(t.text.slice(s,i-t.from)))return{range:e.cursor(t.from+s),changes:{from:t.from+s,to:i}};if(i-t.from==s){let o=t.from+n.from;if(n.item&&n.node.from<n.item.from&&/\S/.test(t.text.slice(n.from,n.to)))return{range:r,changes:{from:o,to:t.from+n.to,insert:n.blank()}};if(o<i)return{range:e.cursor(o),changes:{from:o,to:i}}}}}return o={range:r}});return!o&&(r(t.update(i,{scrollIntoView:!0,userEvent:"delete"})),!0)},v=[{key:"Enter",run:insertNewlineContinueMarkup},{key:"Backspace",run:deleteMarkupBackward}],y=L({matchClosingTags:!1});function markdown(e={}){let{codeLanguages:n,defaultCodeLanguage:o,addKeymap:i=!0,base:{parser:s}=B}=e;if(!(s instanceof k))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");let a,f=e.extensions?[e.extensions]:[],c=[y.support];o instanceof u?(c.push(o.support),a=o.language):o&&(a=o);let g=n||a?(h=n,p=a,e=>{if(e&&h){let t=null;if(t="function"==typeof h?h(e):m.matchLanguageName(h,e,!0),t instanceof m)return t.support?t.support.language.parser:l.getSkippingParser(t.load());if(t)return t.parser}return p?p.parser:null}):void 0;var h,p;return f.push(x({codeParser:g,htmlParser:y.language.parser})),i&&c.push(t.high(r.of(v))),new u(mkLang(s.configure(f)),c)}export{B as commonmarkLanguage,deleteMarkupBackward,insertNewlineContinueMarkup,markdown,v as markdownKeymap,w as markdownLanguage};